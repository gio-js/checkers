#include "models.h"
#include "const.h"
#include "enums.h"
#include "shared.h"
#include "functions.h"

/**
 * Analyze the tree movements generated by the specified one, a sum of scores on the movements will
 * be returned as a determination of the path quality
 */
int analyzeMovementPath(t_GameSession *clone, t_AvailableMovement movement, int level, int score) {

	// finishe deep lookup in the paths of movmente
	if (level < 0)
		return score;
	
	// begin movement	
	beginPlayerMovement(clone, movement.SourceX, movement.SourceY);

	// until the movement is not finished
	int movementScore = 0, playerTypeOfTheMovement = clone->PlayerInTurn->PlayerType;
	while(clone->MovementInProgress == 1)
		movementScore += endPlayerMovement(clone, movement.DestinationX, movement.DestinationY);

	// score is added only when the current player is the computer
	if (playerTypeOfTheMovement == PLAYER_TYPE_COMPUTER)
		score += movementScore;
	else
		score -= movementScore;

	// lookup fot further available movements (now we're looking for the opponent of the last movement player)
	t_AvailableMovement currentPathAvailableMovements = getAvailableMovements(clone, clone->PlayerInTurn);
	while (currentPathAvailableMovements.SourceX >= 0) {

		// we are going to clone again the possibilities of movements, the clone is necessary in order to mantain the current
		// game session inalterated
		t_GameSession *innerClone;
		innerClone = (t_GameSession *)cloneGameSession(clone);

		// calculate score for the new movement path
		score += analyzeMovementPath(innerClone, currentPathAvailableMovements, level - 1, score);

		// next
		if (currentPathAvailableMovements.Next == NULL)
			break;

		currentPathAvailableMovements = *currentPathAvailableMovements.Next;
	}

}

/**
 * Retrieves the best movement for the computer player
 */
t_AvailableMovement findBestAvailableMovement(t_GameSession *gameSession) {
	int bestScore = -1;
	t_AvailableMovement bestMovement;
	memset(&bestMovement, 0, sizeof bestMovement);
	t_AvailableMovement currentPathAvailableMovements = getAvailableMovements(gameSession, gameSession->PlayerInTurn);

	// for each available movement
	while (currentPathAvailableMovements.SourceX >= 0) {

		// calculate the score
		int movementScore = -1;

		// clone the game session in order to work on a copy and not change the current game status
		t_GameSession *clone;
		clone = (t_GameSession *)cloneGameSession(gameSession);

		// analyze recoursively the movements and find most efficient movement
		movementScore = analyzeMovementPath(clone, currentPathAvailableMovements, AI_DEEP_PATH_ANALYSIS, 0);

		if (movementScore > bestScore) {
			bestScore = movementScore;
			bestMovement = currentPathAvailableMovements;
		}

		// next
		if (currentPathAvailableMovements.Next == NULL)
			break;

		currentPathAvailableMovements = *currentPathAvailableMovements.Next;
	}

	return bestMovement;
}


/**
 * Simulate a movement by CPU
 * Returns: 1 movement completed, 0 can not execute any movement
 */
int makeMovementByCPU(t_GameSession *gameSession) {
	t_AvailableMovement movement = findBestAvailableMovement(gameSession);

	if (movement.SourceX < 0)
		return 0;

	// begin movement
	beginPlayerMovement(gameSession, movement.SourceX, movement.SourceY);

	// until the movement is not finished
	int movementScore = 0;
	while(gameSession->MovementInProgress == 1)
		movementScore += endPlayerMovement(gameSession, movement.DestinationX, movement.DestinationY);
		
	return 1;
}
