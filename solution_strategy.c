#include "models.h"
#include "const.h"
#include "enums.h"
#include "shared.h"
#include "functions.h"

/**
 * Analyze the tree movements generated by the specified one, a sum of scores on the movements will
 * be returned as a determination of the path quality
 */
int analyzeMovementPath(t_GameSession *gameSession, t_AvailableMovement movement, int level, int score) {

	// finishe deep lookup in the paths of movmente
	if (level < 0)
		return score;


	// clone the game session, in order to work on a copy and not change the current game status
	t_GameSession *clone;
	clone = (t_GameSession *)cloneGameSession(gameSession);

	// begin movement
	beginPlayerMovement(clone, movement.Piece->X, movement.Piece->Y);

	// until the movement is not finished
	int movementScore = 0;
	while(clone->MovementInProgress == 1)
		movementScore += endPlayerMovement(clone, movement.DestinationX, movement.DestinationY);

	// score is added only when the current player is the computer
	if (clone->PlayerInTurn->PlayerType == PLAYER_TYPE_COMPUTER)
		score += movementScore;
	else
		score -= movementScore;

	// lookup fot further available movements
	t_AvailableMovement currentPathAvailableMovements = getAvailableMovements(clone, clone->PlayerInTurn);
	while (currentPathAvailableMovements.Piece != NULL) {

		// calculate score for the new movement path
		score += analyzeMovementPath(clone, currentPathAvailableMovements, level - 1, score);

		// next
		if (currentPathAvailableMovements.Next == NULL)
			break;

		currentPathAvailableMovements = *currentPathAvailableMovements.Next;
	}

}

/**
 * Retrieves the best movement for the computer player
 */
t_AvailableMovement findBestAvailableMovement(t_GameSession *gameSession) {
	int bestScore = -1;
	t_AvailableMovement bestMovement;
	memset(&bestMovement, 0, sizeof bestMovement);
	t_AvailableMovement currentPathAvailableMovements = getAvailableMovements(gameSession, gameSession->PlayerInTurn);

	while (currentPathAvailableMovements.Piece != NULL) {

		// calculate score for the new movement path
		int movementScore = -1;
		movementScore = analyzeMovementPath(gameSession, currentPathAvailableMovements, 3, 0);

		if (movementScore > bestScore) {
			bestScore = movementScore;
			bestMovement = currentPathAvailableMovements;
		}

		// next
		if (currentPathAvailableMovements.Next == NULL)
			break;
			
		currentPathAvailableMovements = *currentPathAvailableMovements.Next;
	}

	return bestMovement;
}


/**
 * Simulate a movement by CPU
 * Returns: 1 movement completed, 0 can not execute any movement
 */
int makeMovementByCPU(t_GameSession *gameSession) {
	t_AvailableMovement movement = findBestAvailableMovement(gameSession);
	
	if (movement.Piece == NULL)
		return 0;

	// begin movement
	beginPlayerMovement(gameSession, movement.Piece->X, movement.Piece->Y);

	// until the movement is not finished
	int movementScore = 0;
	while(gameSession->MovementInProgress == 1)
		movementScore += endPlayerMovement(gameSession, movement.DestinationX, movement.DestinationY);
}
